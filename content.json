{"meta":{"title":"HankXie的博客","subtitle":"","description":"","author":"Xiehan","url":"http://yoursite.com"},"pages":[],"posts":[{"title":"springBoot中Modubus协议连接工具类","slug":"springBoot中Modubus协议连接工具类","date":"2021-12-14T01:42:21.962Z","updated":"2021-12-14T01:47:16.384Z","comments":false,"path":"2021/12/14/springBoot中Modubus协议连接工具类/","link":"","permalink":"http://yoursite.com/2021/12/14/springBoot%E4%B8%ADModubus%E5%8D%8F%E8%AE%AE%E8%BF%9E%E6%8E%A5%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"###1. maven依赖 12345&lt;dependency&gt; &lt;groupId&gt;com.infiniteautomation&lt;&#x2F;groupId&gt; &lt;artifactId&gt;modbus4j&lt;&#x2F;artifactId&gt; &lt;version&gt;3.0.3&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; ###2. 代码（包含02 03 04 05功能码） 说明：目前工具类中定义了一个静态的tcpMaster，可以在main方法中调用不同功能码函数时传入。这种方式在实际开发时可以定一个连接池，可以避免一直创建连接，避免未知错误。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276import com.serotonin.modbus4j.ModbusFactory;import com.serotonin.modbus4j.ModbusMaster;import com.serotonin.modbus4j.exception.ModbusInitException;import com.serotonin.modbus4j.exception.ModbusTransportException;import com.serotonin.modbus4j.ip.IpParameters;import com.serotonin.modbus4j.msg.*;import com.serotonin.modbus4j.sero.util.queue.ByteQueue;import lombok.extern.slf4j.Slf4j;import java.util.Arrays;&#x2F;** * @author xiehan * @version 1.0 * @date 2020&#x2F;6&#x2F;24 14:38 *&#x2F;@Slf4jpublic class Modbus4jUtils &#123; &#x2F;** * 工厂。 *&#x2F; static ModbusFactory modbusFactory; &#x2F;&#x2F;建立链接 static ModbusMaster tcpMaster; static &#123; if (modbusFactory &#x3D;&#x3D; null) &#123; modbusFactory &#x3D; new ModbusFactory(); tcpMaster &#x3D; getMaster(&quot;192.168.1.xxx&quot;,502); &#125; &#125; &#x2F;** * 获取master * * @return * @throws ModbusInitException *&#x2F; public static ModbusMaster getMaster(String ip,Integer port)&#123; IpParameters params &#x3D; new IpParameters(); params.setHost(ip); params.setPort(port); &#x2F;&#x2F;params.setHost(&quot;192.168.1.xxx&quot;); &#x2F;&#x2F;params.setPort(502); &#x2F;&#x2F; modbusFactory.createRtuMaster(wapper); &#x2F;&#x2F;RTU 协议 &#x2F;&#x2F; modbusFactory.createUdpMaster(params);&#x2F;&#x2F;UDP 协议 &#x2F;&#x2F; modbusFactory.createAsciiMaster(wrapper);&#x2F;&#x2F;ASCII 协议 ModbusMaster master &#x3D; modbusFactory.createTcpMaster(params, true);&#x2F;&#x2F; TCP 协议 try &#123; master.setTimeout(5000); master.setRetries(3); master.init(); &#125; catch (ModbusInitException e) &#123; e.printStackTrace(); &#125; return master; &#125; &#x2F;** * 读取离散输入状态[02] * @param start 开始位 * @param readLenth 位数 * @return * @throws ModbusInitException *&#x2F; public static ByteQueue modbusTCP02(int slaveId,ModbusMaster tcpMaster,int start, int readLenth) throws ModbusInitException &#123; &#x2F;&#x2F;建立链接 &#x2F;&#x2F;ModbusMaster tcpMaster &#x3D; getMaster(ip,port); &#x2F;&#x2F;发送请求 ModbusRequest modbusRequest&#x3D;null; try &#123; modbusRequest &#x3D; new ReadDiscreteInputsRequest(slaveId, start, readLenth);&#x2F;&#x2F;功能码02 &#125; catch (ModbusTransportException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;收到响应 ReadResponse modbusResponse&#x3D;null; try &#123; modbusResponse &#x3D; (ReadResponse) tcpMaster.send(modbusRequest); System.out.println(modbusResponse.getData()); System.out.println(Arrays.toString(modbusResponse.getBooleanData())); &#125; catch (ModbusTransportException e) &#123; e.printStackTrace(); &#125; ByteQueue byteQueue&#x3D; new ByteQueue(12); modbusResponse.write(byteQueue); System.out.println(&quot;功能码:&quot;+modbusRequest.getFunctionCode()); System.out.println(&quot;从站地址:&quot;+modbusRequest.getSlaveId()); System.out.println(&quot;开始地址:&quot;+start); System.out.println(&quot;收到的响应信息大小:&quot;+byteQueue.size()); System.out.println(&quot;收到的响应信息值:&quot;+byteQueue); return byteQueue; &#125; &#x2F;** * 读取离散输入状态[02] * @param start 开始位 * @param readLength 位数 * @return 返回boolean数组 * @throws *&#x2F; public static boolean[] modbusTCP02Boolean(int slaveId, ModbusMaster tcpMaster, int start, int readLength) &#123; ModbusRequest modbusRequest; ReadResponse modbusResponse; boolean [] ret &#x3D; null; try &#123; modbusRequest &#x3D; new ReadDiscreteInputsRequest(slaveId, start, readLength);&#x2F;&#x2F;功能码02 modbusResponse &#x3D; (ReadResponse) tcpMaster.send(modbusRequest); if(modbusResponse.isException())&#123; log.error(&quot;读取异常 &#123;&#125;&quot;,modbusResponse.getExceptionMessage()); return ret; &#125; ret &#x3D; modbusResponse.getBooleanData(); &#125; catch (ModbusTransportException e) &#123; log.error(&quot;02功能码读取异常 &quot;,e); &#125; return ret; &#125; &#x2F;** * 读取保持寄存器[03] * @param start 开始地址 * @param readLenth 读取数量 * @return 返回short 数组 * @throws *&#x2F; public static short[] modbusTCP03Short(int slaveId,ModbusMaster tcpMaster,int start, int readLenth) &#123; ModbusRequest modbusRequest &#x3D; null; ReadResponse modbusResponse &#x3D; null; short [] ret &#x3D; null; try &#123; modbusRequest &#x3D; new ReadHoldingRegistersRequest(slaveId, start, readLenth);&#x2F;&#x2F;功能码03 modbusResponse &#x3D; (ReadResponse) tcpMaster.send(modbusRequest); ret &#x3D; modbusResponse.getShortData(); &#125; catch (ModbusTransportException e) &#123; log.error(&quot;03功能码读取异常 &quot;,e); &#125; return ret; &#125; &#x2F;** * 读取保持寄存器[03] * @param start 开始地址 * @param readLenth 读取数量 * @return * @throws ModbusInitException *&#x2F; public static ByteQueue modbusTCP03(int slaveId,ModbusMaster tcpMaster,int start, int readLenth) throws ModbusInitException &#123; &#x2F;&#x2F;建立链接 &#x2F;&#x2F;ModbusMaster tcpMaster &#x3D; getMaster(ip,port); &#x2F;&#x2F;发送请求 ModbusRequest modbusRequest&#x3D;null; try &#123; modbusRequest &#x3D; new ReadHoldingRegistersRequest(slaveId, start, readLenth);&#x2F;&#x2F;功能码03 &#125; catch (ModbusTransportException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;收到响应 ModbusResponse modbusResponse&#x3D;null; try &#123; modbusResponse &#x3D; tcpMaster.send(modbusRequest); &#125; catch (ModbusTransportException e) &#123; e.printStackTrace(); &#125; ByteQueue byteQueue&#x3D; new ByteQueue(12); modbusResponse.write(byteQueue); System.out.println(&quot;功能码:&quot;+modbusRequest.getFunctionCode()); System.out.println(&quot;从站地址:&quot;+modbusRequest.getSlaveId()); System.out.println(&quot;开始地址:&quot;+start); System.out.println(&quot;收到的响应信息大小:&quot;+byteQueue.size()); System.out.println(&quot;收到的响应信息值:&quot;+byteQueue); return byteQueue; &#125; &#x2F;** * 读取输入寄存器[04] * @param start 开始地址 * @param readLenth 读取数量 * @return * @throws ModbusInitException *&#x2F; public static ByteQueue modbusTCP04(int slaveId, ModbusMaster tcpMaster, int start, int readLenth) throws ModbusInitException &#123; &#x2F;&#x2F;建立链接&#x2F;&#x2F; ModbusMaster tcpMaster &#x3D; getMaster(ip,port); &#x2F;&#x2F;发送请求 ModbusRequest modbusRequest&#x3D;null; try &#123; modbusRequest &#x3D; new ReadInputRegistersRequest(slaveId, start, readLenth);&#x2F;&#x2F;功能码04 &#125; catch (ModbusTransportException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;收到响应 ModbusResponse modbusResponse&#x3D;null; try &#123; modbusResponse &#x3D; tcpMaster.send(modbusRequest); &#125; catch (ModbusTransportException e) &#123; e.printStackTrace(); &#125; ByteQueue byteQueue&#x3D; new ByteQueue(12); modbusResponse.write(byteQueue); System.out.println(&quot;功能码:&quot;+modbusRequest.getFunctionCode()); System.out.println(&quot;从站地址:&quot;+modbusRequest.getSlaveId()); System.out.println(&quot;开始地址:&quot;+start); System.out.println(&quot;收到的响应信息大小:&quot;+byteQueue.size()); System.out.println(&quot;收到的响应信息值:&quot;+byteQueue); return byteQueue; &#125; &#x2F;** * 读取输入寄存器[04] * @param start 开始地址 * @param readLenth 读取数量 * @return * @throws ModbusInitException *&#x2F; public static short[] modbusTCP04Short(int slaveId, ModbusMaster tcpMaster, int start, int readLenth)&#123; ModbusRequest modbusRequest &#x3D; null; ReadResponse modbusResponse &#x3D; null; short [] ret &#x3D; null; try &#123; modbusRequest &#x3D; new ReadInputRegistersRequest(slaveId, start, readLenth);&#x2F;&#x2F;功能码03 modbusResponse &#x3D; (ReadResponse) tcpMaster.send(modbusRequest); ret &#x3D; modbusResponse.getShortData(); System.out.println(&quot;功能码:&quot;+modbusRequest.getFunctionCode()); System.out.println(&quot;从站地址:&quot;+modbusRequest.getSlaveId()); System.out.println(&quot;开始地址:&quot;+start); System.out.println(&quot;收到的响应信息值:&quot;+Arrays.toString(ret)); &#125; catch (ModbusTransportException e) &#123; log.error(&quot;04功能码读取异常 &quot;,e); &#125; return ret; &#125; &#x2F;** * 写单个线圈[05] * @param writeOffset 开始位 * @param writeValue true false * @return * @throws ModbusInitException *&#x2F; public static ByteQueue modbusTCP05(int slaveId,ModbusMaster tcpMaster,int writeOffset, boolean writeValue) throws ModbusInitException &#123; &#x2F;&#x2F;建立链接 &#x2F;&#x2F;ModbusMaster tcpMaster &#x3D; getMaster(ip,port); &#x2F;&#x2F;发送请求 ModbusRequest modbusRequest&#x3D;null; try &#123; modbusRequest &#x3D; new WriteCoilRequest(slaveId, writeOffset, writeValue);&#x2F;&#x2F;功能码05 &#125; catch (ModbusTransportException e) &#123; e.printStackTrace(); &#125; &#x2F;&#x2F;收到响应 ModbusResponse modbusResponse&#x3D;null; try &#123; modbusResponse &#x3D; tcpMaster.send(modbusRequest); &#125; catch (ModbusTransportException e) &#123; e.printStackTrace(); &#125; ByteQueue byteQueue&#x3D; new ByteQueue(12); modbusResponse.write(byteQueue); System.out.println(&quot;功能码:&quot;+modbusRequest.getFunctionCode()); System.out.println(&quot;从站地址:&quot;+modbusRequest.getSlaveId()); System.out.println(&quot;收到的响应信息大小:&quot;+byteQueue.size()); System.out.println(&quot;收到的响应信息值:&quot;+byteQueue); return byteQueue; &#125;&#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"FreeMarker导出word文档","slug":"FreeMarker导出word文档","date":"2021-12-14T01:27:49.396Z","updated":"2021-12-14T01:27:54.055Z","comments":false,"path":"2021/12/14/FreeMarker导出word文档/","link":"","permalink":"http://yoursite.com/2021/12/14/FreeMarker%E5%AF%BC%E5%87%BAword%E6%96%87%E6%A1%A3/","excerpt":"","text":"1. maven依赖12345&lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;&#x2F;groupId&gt; &lt;artifactId&gt;freemarker&lt;&#x2F;artifactId&gt; &lt;version&gt;2.3.29&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 2. 参考博文https://www.cnblogs.com/duanrantao/p/9377818.html","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"easyexcel实现表格填充导出","slug":"easyexcel实现表格填充导出","date":"2021-12-13T09:41:11.712Z","updated":"2021-12-13T10:06:37.179Z","comments":false,"path":"2021/12/13/easyexcel实现表格填充导出/","link":"","permalink":"http://yoursite.com/2021/12/13/easyexcel%E5%AE%9E%E7%8E%B0%E8%A1%A8%E6%A0%BC%E5%A1%AB%E5%85%85%E5%AF%BC%E5%87%BA/","excerpt":"","text":"1. maven依赖12345678910111213&lt;!-- excel工具 --&gt;&lt;dependency&gt;&lt;groupId&gt;org.apache.poi&lt;&#x2F;groupId&gt;&lt;artifactId&gt;poi-ooxml&lt;&#x2F;artifactId&gt;&lt;version&gt;4.1.2&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;&lt;!-- easyexcel工具 --&gt;&lt;dependency&gt;&lt;groupId&gt;com.alibaba&lt;&#x2F;groupId&gt;&lt;artifactId&gt;easyexcel&lt;&#x2F;artifactId&gt;&lt;version&gt;3.0.5&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt; 2. 官方参考文档地址https://www.yuque.com/easyexcel/doc/easyexcel","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"进程、线程、协程、并发、并行 概念介绍","slug":"进程线程协程并发并行概念介绍","date":"2020-04-23T03:53:03.746Z","updated":"2020-04-23T03:53:03.753Z","comments":false,"path":"2020/04/23/进程线程协程并发并行概念介绍/","link":"","permalink":"http://yoursite.com/2020/04/23/%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B%E5%B9%B6%E5%8F%91%E5%B9%B6%E8%A1%8C%E6%A6%82%E5%BF%B5%E4%BB%8B%E7%BB%8D/","excerpt":"","text":"1、进程/线程1.1、进程是程序在操作系统中的一次执行过程，系统进行资源分配和调度的一个独立单位。 1.2、线程是进程的一个执行实体，是 CPU 调度和分派的基本单位，它是比进程更小的能独立运行的基本单位。 一个进程可以创建和撤销多个线程，同一个进程中的多个线程之间可以并发执行。 2、并发/并行2.1、并发多线程程序在单核心的 cpu 上运行，称为并发； 2.2、并行多线程程序在多核心的 cpu 上运行，称为并行。 2.3、并发与并行区别？并发与并行并不相同， 并发主要由切换时间片来实现“同时”运行， 并行则是直接利用多核实现多线程的运行，Go程序可以设置使用核心数，以发挥多核计算机的能力。 2.4、上下文并发意味着程序在运行时有多个执行上下文，对应着多个调用栈 3、协程/线程3.1、协程协程：独立的栈空间，共享堆空间，调度由用户自己控制，本质上有点类似于用户级线程，这些用户级线程的调度也是自己实现的。 3.2、线程线程：一个线程上可以跑多个协程，协程是轻量级的线程。","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}]},{"title":"windows下使用nvm自由切换node版本","slug":"windows下使用nvm自由切换node版本","date":"2020-04-15T13:03:43.551Z","updated":"2021-12-14T01:34:47.714Z","comments":false,"path":"2020/04/15/windows下使用nvm自由切换node版本/","link":"","permalink":"http://yoursite.com/2020/04/15/windows%E4%B8%8B%E4%BD%BF%E7%94%A8nvm%E8%87%AA%E7%94%B1%E5%88%87%E6%8D%A2node%E7%89%88%E6%9C%AC/","excerpt":"","text":"在接触nvm前查看了很多资料，但是总有些一些地方迷迷糊糊的，但幸好磕磕碰碰最后也算安装成功了。在此文中，会特意指明一些坑，防止再次踩坑。第一个坑就是，如果你已经单独安装了node，建议先卸载，再来看本文。 1. nvm 下载 nvm 的下载地址：https://github.com/coreybutler/nvm-windows/releases 。选择第一个 nvm-noinstall.zip ，然后解压在系统盘（一般开发相关的文件我都放C盘，但是放别的盘也是可以的）。我放的目录路径是C:\\dev\\nvm。解压出来的文件有： elevate.cmd elevate.vbs install.cmd LICENSE nvm.exe 2. nvm 安装 双击 install.cmd ，是以控制台形式显示的，第一下直接按回车，然后会在C盘根目录产生settings.txt，把这个文件放进刚刚解压的那个目录，然后修改settings.txt内容，改成下面那样： 123456root: C:\\dev\\nvmpath: C:\\dev\\nodejs arch: 64proxy: none node_mirror: http:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;node&#x2F;npm_mirror: https:&#x2F;&#x2F;npm.taobao.org&#x2F;mirrors&#x2F;npm&#x2F; 但是有些人很不幸，这个方法行不通，因为打开 install.cmd按下回车后，显示拒绝访问注册表路径，并弹出一个settings.txt。这时候，你只要淡定地叉掉那个文本以及控制台，然后在刚刚的目录里新建一个文件settings.txt，最后把上面的内容复制进去就可以了。 root ： nvm的存放地址 path ： 存放指向node版本的快捷方式，使用nvm的过程中会自动生成。一般写的时候与nvm同级。 arch ： 电脑系统是64位就写64,32位就写32 proxy ： 代理 3. nvm 配置 以控制台方法执行成功的，在环境变量里会自动配置了 NVM_HOME 和 NVM_SYMLINK ，这时候只要修改相应的路径就行了。 直接创建settings文件的可以在环境变量里创建 NVM_HOME 和 NVM_SYMLINK，并添加路径要是嫌弃可视化界面打开环境变量的步骤太麻烦，可以直接使用 ** windows+r =&gt; sysdm.cpl ** 12NVM_HOME： C:\\dev\\nvmNVM_SYMLINK ： C:\\dev\\nodejs 在PATH里加上;%NVM_HOME%;%NVM_SYMLINK%;。一键控制台install的还要检查 环境变量 PATH 上的路径有没有添加C:\\dev\\nvm以及C:\\dev\\nodejs,有的话就删掉。 4. 检测安装结果 打开控制台，输入：nvm -v,若是出现版本信息，则安装。若报错，那就重新把步骤再捋一遍。 检查环境变量是否配置成功：可以在控制台输入：set [环境变量名]，查看路径是否填写错误 5. 使用node 控制台下载 =&gt; 输入：nvm install [版本号]，下载最新版的可以直接输nvm install latest 下载完成后，在控制台输入：nvm use [版本号]。即使用这个版本号的node了。在use后，上面所说的nodejs文件夹就自动生成了。（在use之前是没有的哦）6. 使用效果标*代表当前版本","categories":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}],"tags":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/tags/%E5%B7%A5%E5%85%B7/"}],"keywords":[{"name":"工具","slug":"工具","permalink":"http://yoursite.com/categories/%E5%B7%A5%E5%85%B7/"}]},{"title":"angularjs实现生成二维码","slug":"angularjs实现生成二维码","date":"2020-04-15T13:02:36.747Z","updated":"2021-12-14T01:32:10.190Z","comments":false,"path":"2020/04/15/angularjs实现生成二维码/","link":"","permalink":"http://yoursite.com/2020/04/15/angularjs%E5%AE%9E%E7%8E%B0%E7%94%9F%E6%88%90%E4%BA%8C%E7%BB%B4%E7%A0%81/","excerpt":"","text":"一 引用文件123&#x2F;&#x2F;index.html &lt;script src&#x3D;&quot;lib&#x2F;qrcode&#x2F;jquery.min.js&quot;&gt;&lt;&#x2F;script&gt; &lt;script src&#x3D;&quot;lib&#x2F;qrcode&#x2F;qrcode.js&quot;&gt;&lt;&#x2F;script&gt; 链接: https://pan.baidu.com/s/1skLb1Rv 密码: bt19 二 编码html 核心代码 12&lt;input type&#x3D;&quot;text&quot; placeholder&#x3D;&quot;扫出来的值&quot; ng-model&#x3D;&quot;urlData.url&quot;&gt;&lt;button class&#x3D;&quot;button button-calm&quot; style&#x3D;&quot;margin: 5px;height: 50px;&quot; ng-click&#x3D;&quot;qrCode()&quot;&gt;生成&lt;&#x2F;button&gt; controller 1234567891011121314151617181920212223242526272829&#x2F;** * Created by xiehan on 2017&#x2F;12&#x2F;13. *&#x2F;angular.module(&#39;studyApp.controllers&#39;) .controller(&#39;QrCodeCtrl&#39;, function ($scope, $sce,$rootScope,$ionicHistory, $location) &#123; $scope.title &#x3D; &#39;二维码生成&#39;; $scope.goBack &#x3D; function () &#123; $ionicHistory.goBack(); &#125;; $scope.urlData&#x3D;&#123; url:&#39;&#39; &#125;; &#x2F;&#x2F;初始化二维码宽高 var qrcode &#x3D; new QRCode(document.getElementById(&quot;qrcode&quot;), &#123; width: 200, height: 200, colorDark : &#39;#000000&#39;, &#x2F;&#x2F; 前景色 colorLight : &#39;#ffffff&#39;, &#x2F;&#x2F; 背景色 correctLevel : QRCode.CorrectLevel.H &#x2F;&#x2F;L M Q H &#125;); $scope.qrCode&#x3D;function()&#123; qrcode.makeCode($scope.urlData.url); &#125; &#125;); 三 封装成指令12345678910111213141516171819202122232425262728293031&#x2F;** * Created by xiehan on 2017&#x2F;12&#x2F;13. *&#x2F;angular.module(&#39;studyApp.directives&#39;) .directive(&#39;qrcode&#39;, function ($compile,$timeout) &#123; return &#123; restrict: &#39;AE&#39;, scope: &#123; url: &#39;&#x3D;&#39; &#125;, template: &#39; &lt;div style&#x3D;&quot;display: flex;align-items: center;justify-content: center;margin-top: 10px;&quot;&gt;&#39;+ &#39;&lt;div id&#x3D;&quot;qrcode&quot;&quot;&gt;&lt;&#x2F;div&gt;&lt;&#x2F;div&gt;&#39;, replace: true, transclude: true, link: function ($scope, element, attrs) &#123; $compile(element.contents())($scope); &#x2F;&#x2F;初始化二维码样式 var qrcode &#x3D; new QRCode(document.getElementById(&quot;qrcode&quot;), &#123; width: 200, height: 200, colorDark : &#39;#000000&#39;, &#x2F;&#x2F; 前景色 colorLight : &#39;#ffffff&#39;, &#x2F;&#x2F; 背景色 correctLevel : QRCode.CorrectLevel.H &#x2F;&#x2F;L M Q H &#125;); qrcode.makeCode($scope.url); &#125; &#125; &#125;); html中只要这样写就可以了 1&lt;qrcode url&#x3D;&quot;urlData.url&quot;&gt;&lt;&#x2F;qrcode&gt; 四 效果图","categories":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"}],"keywords":[{"name":"前端","slug":"前端","permalink":"http://yoursite.com/categories/%E5%89%8D%E7%AB%AF/"}]},{"title":"SpringBoot中Mybatis打印sql","slug":"SpringBoot中Mybatis打印sql","date":"2020-04-15T11:56:44.409Z","updated":"2020-04-16T07:15:06.726Z","comments":false,"path":"2020/04/15/SpringBoot中Mybatis打印sql/","link":"","permalink":"http://yoursite.com/2020/04/15/SpringBoot%E4%B8%ADMybatis%E6%89%93%E5%8D%B0sql/","excerpt":"","text":"如果使用的是application.properties文件，加入如下配置： 1logging.level.com.example.demo.dao&#x3D;debug logging.level.com，后面的路径指的是mybatis对应的方法接口所在的包。并不是mapper.xml所在的包。 如果使用的是application.yml文件，加入如下配置： 1234# 打印sqllogging: level: com.example.demo.dao : debug","categories":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/tags/%E5%90%8E%E7%AB%AF/"}],"keywords":[{"name":"后端","slug":"后端","permalink":"http://yoursite.com/categories/%E5%90%8E%E7%AB%AF/"}]}]}